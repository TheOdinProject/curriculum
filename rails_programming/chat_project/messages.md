Messages represent the individual messages that people send in each room. They don't exist on their own outside of a room and so this makes them a little different to our room model. We can only create messages in reference to a specific room. What this means in terms of our application is that we need to form an association between our room and our messages. Rails has many ways to represent an assocation between two models depending on the nature of their relationship. You can read more about it [here](https://guides.rubyonrails.org/association_basics.html). For our use case here we would call this assocation one-to-many. This is because one room has many messages, but a message only has one room it belongs to. We also have another dimension here because a message belongs to a specific user too. And this can exist outside of the context of a room. For example we might want to have a user profile page which lists all of the messages the user has sent regardless of the room it was posted in.

When we create a model on which we want to represent that belongs_to association we can do so when we create the model by using the `references` column type in the terminal. 
Our model can be called `message`. Lets create the model now. In the terminal type

```bash
bundle exec rails generate model message room:references user:references text:text
```

Although for our references we provided names of `room` and `user` Rails will name those columns `room_id` and `user_id`. This is the standard naming convention for foreign keys so if you are ever creating your own columns to be used as foreign keys and don't use `references` ensure you name the column appropriately or you may find annoying errors when using Rails methods that expect a foreign key to end with `_id`

When you make your own apps you may consider the name `message` to be too generic for the model. Especially if your app grows and you may have many different types of messages. For our use case though message makes sense. Also note we have used the `text` type for our message. This differs from the `string` type you may have seen earlier. The difference is how many characters it is intended to hold. Using `text:string` would have limited our text column to 255 characters whereas a text column type can hold up to 30,000. A comment may be more than 255 characters so it makes sense to use text for this use case.

Open up the migration file generated and make sure users can't submit empty messages.

```ruby
t.text :text, null: false
```

Save the file and then in the terminal run

```bash
bundle exec rails db:migrate
```

Now open up the Message model file generated by Rails and notice how it has added for us the belongs_to assocations for both user and room. This is a direct result of us using `references` when we created the model. By adding these lines we can now reference the associated model in our code. For example if we had a message object we could use `message.room` to get the room object it was associated with and `message.user` to get the user.

Although Rails does add the belongs_to side of our assocations it doesn't automatically write the other side of the association. So we couldn't get a room object and write `room.messages`. We would get an undefined method error. At this stage we don't have a use for finding messages through the user so let's just add the association to the Room model

Open up the Room model and add the following code

```ruby
class Room < ApplicationRecord
  has_many: messages
end
```

Notice how we use the plural of message in a has_many association. This tells Rails that a room can have many associated messages and that it can find which messages belong to a room by looking for that rooms id in the room_id column on the message database table. You don't have to name the column `user_id`. There may be a good reason to name it something else. Maybe you have an app for authors and so all authors are users of your app and have a user model, but in the book table you want to reference them as `author`. It makes more sense to call `book.author` rather than `book.user`. In those cases it is fine to have an `author_id` column in your book table but when you set up the assocation you just need to tell Rails where you go looking for the associatied user object. We won't get into the details here but it's pretty easy to look up if you ever find yourself in that situation.

We can play with this in the rails console to see how it works. We'll do it in the sandbox mode for now so no changes are saved. In the terminal open a console with `bundle exec rails console --sandbox`.

To create a message we need 3 things. A User, a Room and some text. All three are required by our validations. When dealing with assocations when creating a new object Rails lets us pass a user and room object instead of an id. This may seem abstract so let's have a play in the console to show what I mean.

As we need a user and a room the easiest way is to grab the first one of each.

```bash
irb(main):001:0> user = User.first
 # (0.1ms)  begin transaction
 # User Load (0.2ms)  SELECT "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT ?  [["LIMIT", 1]]
irb(main):002:0> room = Room.first
 # Room Load (0.2ms)  SELECT "rooms".* FROM "rooms" ORDER BY "rooms"."id" ASC LIMIT ?  [["LIMIT", 1]]
```

Now we can create a message.

```bash
irb(main):003:0> message = Message.new
 => #<Message id: nil, room_id: nil, user_id: nil, text: nil, created_at: nil, updated_at: nil>
```

Here we can see that the message hasn't set our room, user or text yet so it won't be valid. You already know from our room lessons how to check whether an object is valid and how to see what errors have been set on it.

Now you may think we need to set the user_id and room_id doing something like

```bash
message.room_id = room.id
message.user_id = user.id
```

This makes sense. Our id columns require an integer relating to a user and room. However as mentioned earlier instead of doing this we can work through the association to set these.

```bash
irb(main):005:0> message.room = room
irb(main):006:0> message.user = user
  => #<Message id: nil, room_id: 2, user_id: 1, text: nil, created_at: nil, updated_at: nil>
```

Here you can see setting the room on message to the room object we loaded earlier and doing the same with user adds the relevant id's. Your id's might be different integers depending on how many rooms and users you have.

We could also do this in one line

```bash
Message.new(user: User.first, room: Room.first, text: 'this is a comment')
```

This isn't anything new to you and how most objects are created in Ruby.

Now that you can see how we can work through the assocation to set the id correctly we can also do it on any association. So if we load a room object first we can instead create a new message through the room.messages assocation.

```bash
irb(main):001:0> room = Room.first
  (0.1ms)  begin transaction
  Room Load (0.2ms)  SELECT "rooms".* FROM "rooms" ORDER BY "rooms"."id" ASC LIMIT ?  [["LIMIT", 1]]
irb(main):002:0> room.messages.new
  => #<Message id: nil, room_id: 2, user_id: nil, text: nil, created_at: nil, updated_at: nil>
```

Here see how it sets the room_id already for us on the newly created message because we went through the association. We could have also set the user and text on it as we did earlier.

```bash
room.messages.new(user: User.first, text: 'my best ever comment')
```

Here we don't have to set the room as an argument in the constructor because we have worked through the room association. Hopefully you have an appreciation for how Rails allows us to create objects through an association.

For getting all of the messages assocation with a room you can again work through the assocation.

```bash
irb(main):002:0> room.messages
  Message Load (0.2ms)  SELECT "messages".* FROM "messages" WHERE "messages"."room_id" = ? LIMIT ?  [["room_id", 2], ["LIMIT", 11]]
  => #<ActiveRecord::Associations::CollectionProxy []>
```

Yours may actually have an object in the collection if you are in the same console session so don't worry if it isn't identical. As long as you don't get any errors. You can work the assocation the other way too. If you have a message object in memory you can call `message.user` and `message.room`. In these instances you get the actual object back because it is a belongs_to assocation so there is only one associated object. With `room.messages` there can be zero, one or several and so you actually get back a collection which can be iterated and accessed like an array.

One last point which isn't relevant to what we are doing but you should keep in mind is that if you are working on assocations where the foreign key doesn't match the table it joins to you may find weird behaviour with the associated object not updating with changes made. You might not understand what I mean but read [this section](https://guides.rubyonrails.org/association_basics.html#bi-directional-associations) to understand when you might need to consider using the `inverse_of` option on your assocations.

Now would be a good time to add a couple of tests. One is for validations which we will add and the other is for the associations. There is some thought that testing associations doesn't make sense because you are testing implementation rather than behaviour but we will write them here for two reasons. One is to show you how it would be done and the second is that we don't have any other tests yet to check that our association is set. A key to writing good code is to be willing to delete code when it is no longer needed. So it may be that we test our association is present early on, then later write some system tests that exercise those associations. It would be perfectly reasonable at that time to remove the unit tests for the association to be present. It's also valid to leave them in place as the code itself isn't redundant. Don't be afraid to delete code that isn't needed though, a big source of frustration will be trying to work out what a method does in a codebase that you can't see exercised anywhere because the person who knew it wasn't needed anymore didn't delete it.

To test our assocation is present we can again turn to shoulda-matchers. Assocations are tested under the ActiveRecord part of the gem which you can read about [here](https://github.com/thoughtbot/shoulda-matchers#activerecord-matchers).

The syntax won't surprise you as it's very similar to our validation tests.

Firstly we can test the validation on our room. Open up our room_spec and let's add a test for the has_many assocation.

```ruby
RSpec.describe Room, type: :model do
  describe 'validations' do
    # ...
  end

  describe 'associations' do
    it { is_expected.to have_many :messages }
  end
end
```

That's all there is to it for our room test. Save the file and then run your tests to make sure none are failing.

For our messages we need to test both our validations and associations. When we creating the model using references Rails automatically put a validation in the migration to ensure neither foreign key could be blank but we should also add the validation to the model because that can avoid a connection to the database which has a performance hit.

Open up the message spec file and lets add our validation and association test

```ruby
RSpec.describe RoomMessage, type: :model do
  describe 'validations' do
    it { is_expected.to validate_presence_of :user_id }
    it { is_expected.to validate_presence_of :room_id }
    it { is_expected.to validate_presence_of :text }
  end

  describe 'assocations' do
    it { is_expected.to belong_to :user }
    it { is_expected.to belong_to :room }
  end
end
```

Two of the tests will already pass as Rails added the assocations for us. For the others we need to add the validations. Open up the message model and add the validations

```ruby
class Message < ApplicationRecord
  validates :user_id, presence: true
  validates :room_id, presense: true
  validates :text, presense: true

  belongs_to :room
  belongs_to :user
end
```

Run the test file and make sure everything is green.

We also need a route. Inside config/routes.rb change the line with `resources :rooms` to 

```ruby
resources :rooms do
  resources :messages
end
```

Why have we added our messages into a block inside our rooms routes? This goes back to our earlier comment about how messages don't exist outside of the context of a room. This allows us to set that relationship for our paths. Have a read through the [nested route](https://guides.rubyonrails.org/routing.html#nested-resources) section of the Rails Guides which will explain what nesting a resource does for your application.

In our case it will mean the following routes are created

```bash
room_messages        GET    /rooms/:room_id/messages(.:format)             messages#index
                     POST   /rooms/:room_id/messages(.:format)             messages#create
new_room_message     GET    /rooms/:room_id/messages/new(.:format)         messages#new
edit_room_message    GET    /rooms/:room_id/messages/:id/edit(.:format)    messages#edit
room_message         GET    /rooms/:room_id/messages/:id(.:format)         messages#show
                     PATCH  /rooms/:room_id/messages/:id(.:format)         messages#update
                     PUT    /rooms/:room_id/messages/:id(.:format)         messages#update
                     DELETE /rooms/:room_id/messages/:id(.:format)         messages#destroy
```

Note how whichever path we use we need to pass in the room id. This makes sense for most of the routes. When we create a new message we need to associate it with a room so we need the room id. However it doesn't make sense in all cases. When we delete a message do we need to pass in the room id? Why does this make sense. Likewise for editing a message. Rails provides a simple solution for this. We can either just duplicate the routes outside of the rooms resource.

```ruby
resources :rooms do
  resources :messages
end

resources :messages
```

This would create two sets of routes for messages. One would be the routes as we've seen above and the other would be a standard set of routes similar to that created for our rooms.

The other solution is that we can pass additional arguments in a hash to the resources method to limit which controller methods to limit the route to. You can use `only:` to limit the routes to only those specified in an array you set against the `only:` key, and you can use `except:` to create routes except for those in the array. This isn't limited to nested resources. You may have a standalone resource on which you don't need all the routes and you can set the same options on those.

Which solution you go for will depend on your use case. In our case we don't want to create standalone resources for our message when we list it, create it or show it but we do when we delete it, edit it or update it.

Let's update the routes to limit them to only create the routes we require.

```ruby
resources :rooms do
  resources :messages, only: [:index, :create, :new, :show]
end

resources :messages, only: [:edit, :update, :destroy]
```

I could also have written it using except where the arrays would be reversed. I could also have written one using only and the other except. You also don't have to use both. I might want to limit the routes on the nested resource but have them all available on the standalone resource. Use the one which corresponds to your needs at the time.

In order to display messages in our view we need to pass them from our controller. In our case the message won't have their own view for being displayed but will by displayed inside the room view they are associated with. To view a specific room we use the show method. Therefore that is the controller method we need to add our messages to so we can display them

Inside the rooms controller add the following line to the show method

```ruby
def show
#...
@messages = @room.messages
```

This will grab all of the messages associated with that room. We played around with the concept earlier. We can use this collection of messages to iterate them and display them in our room show page.

We also need a form to submit new messages on each page. To do that we need to give it a new message object to work with which means we also need to add the following line to the show method

```ruby
def show
#...
@message = @room.messages.new
```

Note here that although we are creating a new object, as we are going through the association we still use the plural `.messages`

In order to create new messages we need a form. You should be very familiar with forms at this point but there are some new considerations for us to think about.

First, when we are working with a nested resource we need to pass both resources to the form. This is because the path will be something like `/rooms/1/messages/new`.

Second, we don't want to refresh the page every time we send a message, so in this instance we will use a javascript ajax request to send the message rather than an HTML request.

Third, since we are using an ajax request and the page won't refresh, any input in the form will still be visible after the message has been sent. That means we'll have to clear that ourselves and will give us a chance to work with a small amount of Javascript code.

For the nested resource in a form we'll need to consult the docs once again. Check out the (form_with)[https://api.rubyonrails.org/] Rails api page and see if you can spot what we need. You'll need to scroll down quite far.

From the example in the docs...

"If your resource has associations defined, for example, you want to add comments to the document given so that the routes are set correctly:"


```ruby
<%= form_with(model: [ @document, Comment.new  ]) do |form| %>
  ...
<% end %>
```

So we can see we need a form that passes the room, and new room message in an array to the model parameter of form_with.

Let's write the form. We will use some Bulma stylings and will need some custom css for the look and feel of the page.

Open up our room show view and inside the empty second column let's first add two divs. The first will be a container for all of the messages that get created and the second will be for the message form

```html
<div class="column">
  <div class="message-box"></div>
  <div class="message-form"></div>
</div>
```

Now inside the div with the class `message-form` we can write our form.

```html
<%= form_with model: [@room, @message] do |form| %>
  <div class="field has-addons">
    <div class="control">
      <%= form.text_field :text, class: 'input' %>
    </div>
    <div class="control">
      <%= form.button :submit, class: 'button' do %>
        <span class="icon is-large has-text-success">
          <span class="fa-2x">
            <i class="fas fa-arrow-circle-right"></i>
          </span>
        </span>
      <% end %>
    </div>
  </div>
<% end %>
```

You may have noticed that the submit button above hasn't been written the same way as our other submit buttons in the other forms. This is because I wanted to use an icon to submit the message which requires passing a block to the button. `form.submit` does not accept a block so this is the way Rails recommends to handle it. Keep this in mind if you want your form buttons to use custom html rather than some text.

If you view the form now it won't look very nice. Bulma can only do so much and we'll need to add some custom css to this. We won't really explain the css too much as this isn't the point of the tutorial but we'll give a small explanation of what we are trying to do.

All of our css relates to the room views so we can write our css in `app/assets/stylesheets/room.scss` file. Open that up now.

Firstly we want our div for the messages to take up quite a bit of the screen and we can give it a nice border so it's clear where our messages will be displayed.

Inside the rooms.scss file add the following code

```css
.message-box {
  height: 80vh; 
  border: 1px solid #b8b1fc;
  border-radius: 5px 5px 0 0;
}
```

We also want the input field in the form to take up the majority of the width of the form. So we need to do two things here.

Firstly in the show.html.erb locate the div that surrounds the text input. It will have a class of `control` and add another class of `message-input` so we can target that in our css.

```html
<div class="control message-input">
  <%= form.text_field :text, class: 'input' %>
</div>
```

Then inside the room.scss file we can target that class. As Bulma has already given us a flexbox setup with the stylings we've attached we simply need to add the following to our css file.

```css
.message-input {
  flex-grow: 1;
}
```

This makes the input bar take up most of the space available.

Refresh the page and you should have a nice looking text area and form input.

As we have learned form_with submits as an ajax request by default and as we haven't added the `local: true` option it won't submit as an html request for us. That is exactly what we need. This takes care of points 1 and 2 from above.

For point 3, clearing the form after the user submits their message, we don't yet have the functionality to create the messages so we can come back to this once we know messages are being submitted and created correctly.

If you try and submit the form right now you may wonder why you don't get an error message. We should get one because we don't yet have a RoomMessages controller with the necessary actions. This is because the form is being submitted using an ajax request and therefore there is no page redirect to take us to an error page. However if you check the server logs you'll see there is an error message displayed there.

```bash
ActionController::RoutingError (uninitialized constant RoomMessagesController)
```

To fix this we need to create the controller. Open up a terminal and type

```bash
bundle exec rails g controller messages
```

You may need to restart the server and if you now refresh the browser and resubmit a form entry you'll get a new error that the create action does not exist.

Now that we have a controller we need a create method which our form can submit to. Open up our Message controller and write a create action method.

```ruby
def MessagesController < ApplicationController
  def create

  end
end
```

What should go inside there? Well we know the form is submitted with the `room_id` as a parameter because the route is `/rooms/:room_id/messages`. So we can find the room that our message should be associated with.

```ruby
def create
  @room = Room.find(params[:room_id])
end
```

We already have practice of building a message through the room from when we tested creating objects through associations earlier. So we did `room.messages.new`. What I didn't mention that I will now is when you are actually creating the object through the association in the create method it's convention to use `build` rather than `new`. Build is an alias for new so they do the same thing. The convention to use build now for associations is because in an older version of Rails only using `build` would set the foreign key on the associated object for you. Using `new` just created a blank object even if you did it through an associated object.

As we did with room we also need to set the allowed parameters for new messages.

```ruby
def create
  @room = Room.find(params[:room_id])
  @message = @room.messages.build(message_params)
end

private
  def message_params
    params.require(:message).permit(:text)
  end
```

We only need to permit text because we get our room_id through the association. It isn't submitted through the form.

The last thing we need is to set the user. The person creating a particular message will always be the signed in user so we can leverage a devise helper method `current_user` to set the user_id on the message.

#TODO: Decide if this should be done in a callback

```ruby
def create
  @room = Room.find(params[:room_id])
  @message = @room.messages.build(message_params)
  @message.user = current_user
end
```

The last thing we need to do is save the message.

```ruby
def create
  @room = Room.find(params[:room_id])
  @message = @room.messages.build(message_params)
  @message.user = current_user
  @message.save
end
```
#TODO respond if message does not save

Now that the messages are being created we need to display them in the room. We are already grabbing all of the messages for each room in the rooms controller show method and we already have created a space to display them. So all we need to do is iterate the messages in the view and for each one print out the message.

Open up the rooms show html file and locate the div with the class `message-box` we can add the following code inside that div

```html
<% @messages.each do |message| %>
  <div class="message">
    <div class="message-header">
      <%= message.user.username %>
    </div>
    <div class="message-body">
      <%= message.text %>
    </div>
  </div>
<% end %>
```

Now you should be able to refresh the screen and see any messages you have created. If you haven't created any yet go ahead and make a few and then refresh the screen again.

If you check the server logs you may see something alarming. Each time we add a new room message there is a database request for the user. This is happening because we request the `user.username` for each message. This is known as the N+1 problem.

Say we have 10 messages. For each message we have an associated user. When our Rails app reaches the controller it connects to the database and loads the messages in one database transaction using `@messages = @room.messages`. This is efficient. We only have to connect to the database once. However in the view we display the user for each message. To get this user information Rails needs to connect to the database each time. It can't know inside the loop where we display the messages that there will be future connections needed and optimise the query. This means with our 10 messages we open a database connection once to get the messages and then for each message we connect again to get the user information of that message. 11 database connections opened. Most chatrooms have hundreds if not thousands of messages. With that many database connections for each person in the chatroom needing to load messages in their browser the load time would be terrible and the user experience would suffer. Because for each additional message we need one additional query to get the user information we call it N+1. You should almost always find another way if you are loading data this way.

In order to avoid this problem we need to hit the database for both the room messages and their associated users at the same time. When you load an association this way it is known as Eager Loading. You can read a little bit about it in the (Rails Guides)[https://guides.rubyonrails.org/active_record_querying.html#eager-loading-associations] section on this problem. It also gives us the solution to our problem. Rails has the `includes` method which makes sure ActiveRecord gets our queries with the minimum number of database queries.

Open up the rooms controller and lets include the users with the room messages in the show action

```ruby
@messages = @room.messages.includes(:users)
```

If you refresh the page and check the server logs you'll notice there is no longer a long list of user load queries. Rails has grabbed all the user information when it got the room messages. It might not make much of a difference now, but once a room has potentially thousands of messages you'd definitely notice the difference.

There is one last problem we need to deal with that you'd have noticed if you created enough messages to fill the space we've created for them. They just continue way down past the page which looks pretty terrible. We just need to do a simple css fix. Open the room.scss file in the stylesheets folder we just need to add one line to the `.message-box` target class

```css
.message-box {
  ...
  overflow-y: scroll;
}
```

Now if you refresh the browser you'll see any messages that don't fit are now reachable by a scrollbar.

Now we can finally go back to our earlier goal of clearing the input field when a message has been sent.

To do this we will need to use Javascript. Rails implements the rails_ujs package to handle a lot of javascript actions. If you look at the app/javascript/packs/application.js file you'll see the rails_ujs package is imported and started.

# TODO explain rails UJS

First, we need somewhere to write our script. We should not write scripts in the application.js file. So in app/javascript create a directory called `messages` and as our script relates to our messages create action we can create a file called `create.js` in there.

Only files in the `javascript/packs` directory are compiled so we need somewhere to reference the create.js file in there. As we only need to import one file we could just require it in application.js, but we don't want to overload that if we create more javascript files and this is a good opportunity to learn how we would handle this in a larger application so let's instead create a file called `message.js` inside `javascript/packs`.

This file will be automatically compiled by webpack but it won't be automatically included in our application. For that we need to include this javascript inside our `<head>` element. Open up `app/views/layouts/application.html.erb` and notice in the `<head>` there is already an import for our application.js file in the packs directory. `<%= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %>Â¬`. This is the Rails way to import files from the pack directory.

We need to reference our room_message.js file which we can do the same way. Below the application import add the following line

```html
<%= javascript_pack_tag 'message', data-turbolinks-track':'reload' %>
```

This will ensure our room_message.js file in the packs directory gets imported into our application.

Now the final connection to make is inside message.js we need to require our create.js file from the messages directory. Open message.js and add the following line.

```js
require("room_messages/create")
```

Notice that we don't need to actually specify the path

# TODO explain webpacker source paths

Now everything is setup we can write the javascript code to clear the input.

We want to add an event listener to the form to listen for the `ajax:success` event. As the user won't start on this page we can't just add the event listener straight away as the form won't exist on any other page in our application. If the Javascript runs on our room index page where the form doesn't exist then when we navigate to the show page for any room the javascript will already have been evaluated. Instead we can add an event listener to the document for when the DOM loads each time. Then inside there check if the form is on the current page, and if it is then we can bind the event listener for a successful ajax request to it and clear the form.

One catch to this is that adding an event listener for when the DOM is loaded isn't straightforward when turbolinks is being used. Turbolinks uses ajax to load in data from the server but makes it look like a proper page load. So for this Rails ships with a Javascript event listener called `"turbolinks:load"`. An event listener placed on this will fire when turbolinks has finished loading the page.

To make it easier to target the form let's add an id to it. Open the rooms show.html.erb file and where we create the form add an id as follows

```html
<%= form_with model: [@room, @room_message], id: 'message-form' do |form| %>
```

Inside the create.js file in the room_messages directory add the following code

```js
document.addEventListener('turbolinks:load', () => {
  let form = document.getElementById('message-form')
  if(form) {
    form.addEventListener('ajax:success', (event) => {
      document.querySelector('.input').value = '';
    })
  }
})
```

Refresh the page in the browser and try and submit a message. The form should now clear on submission.

It's a real bummer having to refresh the page to see any newly submitted messages. We can fix that next by implementing a web socket.
